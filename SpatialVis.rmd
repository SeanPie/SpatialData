---
title: "Spatial Experiment"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    toc_depth: 2
---

**Spatial Transcriptomics analysis based on https://lmweber.org/OSTA-book/analysis-steps.html**

For both practice data from github and from mice kidney paper. (recommit)

```{r, include=FALSE} 
library(SpatialExperiment)
library(STexampleData)
library(ggspavis)
library(scater)
library(scran)
library(pheatmap)

```


# Load the data

Create a Spatial Experiment object.
```{r, message=FALSE}

dir <- file.path("~","Desktop","test")

sample1 <-  file.path(dir, "sham", "outs")

shamKidney <- read10xVisium(sample1,
                        type = "sparse", data = "filtered",
                        images = "lowres", load = FALSE)

```

Spatial Experiment objects can created with merged data from multiple tissue samples.
``` {r, message=FALSE}
sample_ids2 <- c("2day", '12hour')
samples2 <- file.path(dir, sample_ids2, "outs")

samples_idsAll <- c('2day', '12hour', 'week', 'sham')
samplesAll <-  file.path(dir, samples_idsAll, 'outs')

#Import visium data for mutiple samples
sham_6weekKidney <- read10xVisium(samples2, sample_ids2,
                        type = "sparse", data = "filtered",
                        images = "lowres", load = FALSE)

allKidneys <- read10xVisium(samplesAll, samples_idsAll,
                        type = "sparse", data = "filtered",
                        images = "lowres", load = FALSE)

```

# Pre-Processing

```{r, figures-side, fig.show="hold", out.width="50%"}
plotSpots(shamKidney)
plotSpots(sham_6weekKidney)
plotSpots(allKidneys)
plotVisium(allKidneys)
plotVisium(shamKidney)
```

# Filtering and Normalization

```{r}
# add some values in 'colData' to annotate spots, also done by addPerCellQC function
# colData(shamKidney)$sum <- colSums(counts(shamKidney))

#All spots already in tissue because using filtered data
shamKidney <- shamKidney[, colData(shamKidney)$in_tissue == TRUE]

#Get a list of gene names using rowData, symbol columns is the names
head(rowData(shamKidney)$symbol)

#Used to look for specific genes, in this example searches for mitochondrial genes
is_mito <- grepl("(^MT-)|(^mt-)", rowData(shamKidney)$symbol) 

table(is_mito)
rowData(shamKidney)$symbol[is_mito]

shamKidney <- addPerCellQC(shamKidney, subsets = list(mito = is_mito))
head(colData(shamKidney))

plotVisium(shamKidney, fill = "sum", trans = "log", highlight = "in_tissue")

```

Thresholds can be used as QC to remove spots that don't meet metrics. Includes among others:

1. Library size

2. Expressed genes

3. Proportion of gene specific reads (mitochondrial in this example)

4. Cells per spot (If available for dataset)

```{r}
hist(colData(shamKidney)$sum, breaks = 20) # Library Size, total sum of UMI counts per spot (included in sum column)

hist(colData(shamKidney)$detected, breaks = 20) # Number of expressed genes per spot (detected column)

hist(colData(shamKidney)$subsets_mito_percent, breaks = 20) # Proportion of mitochondrial genes per spot

# select QC threshold for library size
qc_lib_size <- colData(shamKidney)$sum < 5000
table(qc_lib_size)

colData(shamKidney)$qc_lib_size <- qc_lib_size

# check spatial pattern of discarded spots
plotQC(shamKidney, type = "spots", 
       discard = "qc_lib_size")

# # combined set of discarded spots
# discard <- qc_lib_size | qc_detected | qc_mito | qc_cell_count
# colData(spe)$discard <- discard

# # filter low-quality spots
# spe <- spe[, !colData(spe)$discard]

```
Log based normalization can be performed to scale data approximately and create clusters.
Is this necessary for filtered data?

# Clustering and Visualization

``` {r}
set.seed(123) #quick clustering for pool-based size factors
qclus <- quickCluster(shamKidney)
# table(qclus)

shamKidney <- computeSumFactors(shamKidney, cluster = qclus)
summary(sizeFactors(shamKidney))
hist(sizeFactors(shamKidney), breaks = 20)

shamKidney <-  logNormCounts(shamKidney)
assayNames(shamKidney)
```
Feature selection based on highly variable genes (HVG) and spatially variable genes (SVG).
Should mitochondrial genes be removed? Are they are likely highly expressed and/or are they of biological interest?
SVG selection based on SPARK-X package, HVG based on scran package

``` {r}
# shamKidney <- shamKidney[!is_mito, ]
# dim(shamKidney)

deCells <-  modelGeneVar(shamKidney)

fit <-  metadata(deCells)
plot(fit$mean, fit$var, 
     xlab = "mean of log-expression", ylab = "variance of log-expression")
curve(fit$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

top_hvgs <- getTopHVGs(deCells, prop = 0.1) #prop defines how many HVGS are wanted, 0.1 returns top 10% of genes
length(top_hvgs)

```
PCA and UMAP can be easily produced.
How do PCA/UMAP plots compare to the plots prpduced by loupe browser for 6week sample?
  They are different but I think different because they have 8 clusters, Compared to my 6. 


```{r}
set.seed(123)
shamKidney <- runPCA(shamKidney, subset_row = top_hvgs)
shamKidney <- runUMAP(shamKidney, dimred = "PCA")

# dim(reducedDim(spe, "PCA"))

colnames(reducedDim(shamKidney, "UMAP")) <- paste0("UMAP", 1:2)

plotDimRed(shamKidney, type = "PCA")
plotDimRed(shamKidney, type = "UMAP")

```

Produces clusters of HVGs using graph-based clustering based on the Walktrap method. Applies to top 50 PCs? (Meaning?)

Change K values to get number of clusters less than 8. Are less clusters better or are more clusters more accurate?

```{r}
set.seed(123)
k = 20
g <- buildSNNGraph(shamKidney, k = k, use.dimred = "PCA") #Graph based clustering
g_walk <- igraph::cluster_walktrap(g)
clus <- g_walk$membership
table(clus)

colLabels(shamKidney) <- factor(clus) #Store cluster labels in column 'label' in colData

plotSpots(shamKidney, annotate = "label",
          palette = rainbow(10))

plotVisium(shamKidney, fill = "label", trans = "log", highlight = "in_tissue", palette = rainbow(10))

plotDimRed(shamKidney, type = "PCA",
           annotate = "label", palette = rainbow(10))

plotDimRed(shamKidney, type = "UMAP",
           annotate = "label", palette = rainbow(10))
```

Code to identify marker genes, can also be done using Seurat

``` {r}
rownames(shamKidney) <- rowData(shamKidney)$symbol

markers <- findMarkers(shamKidney, test = 'binom', direction = 'up') #Produces list of clusters equal to clusters from graph based
markers

interesting <- markers[[6]] #selection for which cluster
best_set <- interesting[interesting$Top <= 5, ]
logFCs <- getMarkerEffects(best_set)

pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))

top_genes <- head(rownames(interesting))
plotExpression(shamKidney, x = "label", features = top_genes)

```

